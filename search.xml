<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript - 作用域(Scope)與作用域鏈(Scope Chain)</title>
    <url>/JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope-%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%8F%88-Scope-Chain/</url>
    <content><![CDATA[<p>作用域定義 JavaScript 中變數的影響範圍。作用域鏈為作用域對父級作用域的引用形成的關聯。</p>
<span id="more"></span>

<h1 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h1><p>程式碼中定義變數時，這些變數在程式中的可見性(visibility)和可存取性(accessibility)的範圍。</p>
<p><a href="https://www.w3schools.com/js/js_scope.asp">w3schools</a> 上描述 :</p>
<blockquote>
<p>Scope determines the accessibility (visibility) of variables.</p>
</blockquote>
<p>JavaScript 有下列作用域 :</p>
<ul>
<li>全域作用域(Global Scope)</li>
<li>函式作用域(Function Scope)</li>
<li>區塊作用域(Block Scope)</li>
</ul>
<h2 id="全域作用域-Global-Scope"><a href="#全域作用域-Global-Scope" class="headerlink" title="全域作用域(Global Scope)"></a>全域作用域(Global Scope)</h2><p>在函式(function)及區塊(block)外宣告的變數，可以在任何地方被存取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ABen&quot;</span> <span class="comment">// Global scope</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">2</span> <span class="comment">// Global scope</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="string">&quot;brindle&quot;</span> <span class="comment">// Global scope</span></span><br></pre></td></tr></table></figure>

<h2 id="函式作用域-Function-Scope"><a href="#函式作用域-Function-Scope" class="headerlink" title="函式作用域(Function Scope)"></a>函式作用域(Function Scope)</h2><p>每一個函式都會建立一個函式作用域。在函式內部宣告的變數，只能在函式中被存取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;ABen&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// ABen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>

<p>以 <code>var</code> 宣告的變數具有函式作用域 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;function scope&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(scope) <span class="comment">// function scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(scope) <span class="comment">// ReferenceError: scope is not defined</span></span><br></pre></td></tr></table></figure>

<p>在<strong>嚴格模式</strong>下，函式為區塊作用域 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;block scope&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">func</span>() <span class="comment">// block scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>() <span class="comment">// ReferenceError: func is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="區塊作用域-Block-Scope"><a href="#區塊作用域-Block-Scope" class="headerlink" title="區塊作用域(Block Scope)"></a>區塊作用域(Block Scope)</h2><p>因 ES6 的 <code>let</code> 與 <code>const</code> 變數宣告，<code>&#123;&#125;</code>內部宣告的變數於外部無法存取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="作用域鏈-Scope-Chain"><a href="#作用域鏈-Scope-Chain" class="headerlink" title="作用域鏈(Scope Chain)"></a>作用域鏈(Scope Chain)</h1><p>作用域擁有對父級作用域變數的引用，因此多個嵌套的作用域即形成作用域鏈。</p>
<p>變數查找(Variable Lookup) : 當一個作用域中需要使用某個變數，但在當前作用域下無法存取時，會在作用域鏈中查找，父層作用域是否存在該變數，若最終在全域沒找到則拋出錯誤。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;ABen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> color = <span class="string">&quot;brindle&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> is a <span class="subst">$&#123;age&#125;</span>-year-old <span class="subst">$&#123;color&#125;</span> dog.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">second</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">first</span>() <span class="comment">// ABen is a 2-year-old brindle dog.</span></span><br></pre></td></tr></table></figure>

<p>程式碼中在 second 函式存取的 <code>name</code> 與 <code>age</code> 並非是在自身函式內部宣告的變數，而是通過作用域鏈向外部作用域查找所取得的變數。</p>
<h1 id="語彙環境-Lexical-Environment"><a href="#語彙環境-Lexical-Environment" class="headerlink" title="語彙環境(Lexical Environment)"></a>語彙環境(Lexical Environment)</h1><p>是 JS 引擎內部的(抽象)結構，儲存變數和函式名稱與對應的物件或原始值之間的映射關係。每個語彙環境會保有對父級語彙環境的引用。</p>
<p>當定義一個變數或函式時，它們會被儲存在當前的語彙環境中。當在程式碼中使用這些變數時，JS 引擎會通過查找語彙環境鏈來找到對應的值。</p>
<p>語彙環境由兩部分組成 :</p>
<ol>
<li>環境紀錄(Environmental Record) : 保存當前語彙環境的變數資料。</li>
<li>外部語彙環境的引用(a reference to outer lexical environment) : 保存對父級語彙環境的引用。</li>
</ol>
<h1 id="語彙範疇-Lexical-Scope"><a href="#語彙範疇-Lexical-Scope" class="headerlink" title="語彙範疇(Lexical Scope)"></a>語彙範疇(Lexical Scope)</h1><p>程式執行時 JavaScript 是如何將值對應到正確的變數呢 ?</p>
<p>程式語言一般有兩種類型 :</p>
<ol>
<li>靜態範疇(Static Scoping) :<ul>
<li>注重變數在程式碼中聲明的位置。當前位置找不到變數則向父級查找。</li>
<li>C、Java、JavaScript、Python 等語言採用靜態範疇。</li>
</ul>
</li>
<li>動態範疇(Dynamic Scoping) :<ul>
<li>注重函式呼叫的位置。</li>
<li>Perl 採用動態範疇。</li>
</ul>
</li>
</ol>
<p>程式範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;ABen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Black&quot;</span></span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">boo</span>() <span class="comment">// ABen</span></span><br></pre></td></tr></table></figure>

<p>上面的程式在全域作用域及函式作用域中分別各宣告一個 <code>name</code> 變數，在 boo 函式執行時調用了 foo 函式，因為 JavaScript 採用靜態範疇，所以當在 foo 中找不到 <code>name</code> 時，不會因為是在 boo 中被呼叫就使用 boo 中宣告的 <code>name</code>，而是向當前位置的父級範疇查找，最後就在全域中取得變數。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a><br><a href="https://medium.com/@anilakgunes/scope-lexical-environment-and-scope-chain-in-javascript-559aadb7dca8">Scope, Lexical Environment and Scope Chain in JavaScript</a><br><a href="https://medium.com/itsems-frontend/javascript-scope-and-scope-chain-ca17a1068c96">[JavaScript] Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 執行環境(Execution Context)與執行堆疊(Call Stack)</title>
    <url>/JavaScript-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-Execution-Context-%E8%88%87%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A-Call-Stack/</url>
    <content><![CDATA[<p>每呼叫一個函式就會產生一個 Execution Context，並且放入 Call Stack 中等待執行，JavaScript 就是藉由 Call<br>Stack 來追蹤程式的運行。</p>
<span id="more"></span>

<h1 id="執行環境-Execution-Context"><a href="#執行環境-Execution-Context" class="headerlink" title="執行環境(Execution Context)"></a>執行環境(Execution Context)</h1><p>全域與函式程式碼的 JS 內部構造。</p>
<p>JavaScript 的兩種執行環境 :</p>
<ul>
<li>全域執行環境(Global Execution Context)</li>
<li>函式執行環境(Function Execution Context)</li>
</ul>
<p>執行環境包含兩個階段 : 創建階段(creation phase)、執行階段(execution phase)。</p>
<h2 id="全域執行環境-Global-Execution-Context"><a href="#全域執行環境-Global-Execution-Context" class="headerlink" title="全域執行環境(Global Execution Context)"></a>全域執行環境(Global Execution Context)</h2><p>一開始執行 JS 程式碼時所創建的執行環境。</p>
<p>創建階段(creation phase) :</p>
<ol>
<li>創建 global object。(瀏覽器的 window object 或 Node.js 的 global object。)</li>
<li>建立 scope。</li>
<li>創建 <code>this</code>，並綁定至 global object。</li>
<li>將 variables、class 和 function 分配至記憶體。(hoisting)</li>
</ol>
<p>執行階段(execution phase) :</p>
<ol>
<li>逐行執行程式碼。</li>
<li>遇到遞迴時，使用 Call Stack 排定執行順序。</li>
</ol>
<h2 id="函式執行環境-Function-Execution-Context"><a href="#函式執行環境-Function-Execution-Context" class="headerlink" title="函式執行環境(Function Execution Context)"></a>函式執行環境(Function Execution Context)</h2><p>每次調用函式即創建的執行環境。</p>
<p>創建階段(creation phase) :</p>
<ol>
<li>創建 arguments object。</li>
<li>建立 scope。</li>
<li>創建 <code>this</code>。</li>
<li>將 variables、class 和 function 分配至記憶體。(hoisting)</li>
</ol>
<p>執行階段(execution phase) :</p>
<ol>
<li>逐行執行程式碼。</li>
<li>遇到遞迴時，使用 Call Stack 排定執行順序。</li>
</ol>
<h1 id="呼叫堆疊-Call-Stack"><a href="#呼叫堆疊-Call-Stack" class="headerlink" title="呼叫堆疊(Call Stack)"></a>呼叫堆疊(Call Stack)</h1><p>是 JS 引擎追蹤本身在調用多個函式的程式碼中所在位置的機制。可以幫助我們知道 JS 引擎當前正在運行什麼函式，以及該從函式中調用那些函式。</p>
<p>JavaScript 為單執行緒(single thread)的程式語言，指一次只能執行一個任務，而其他任務會依序添加到堆疊中，等待被執行。</p>
<blockquote>
<p>堆疊(Stack) : 具有後進先出(LIFO, Last In First Out)特性的資料結構。</p>
</blockquote>
<p>執行以下程式碼 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;func1 開始執行&quot;</span>)</span><br><span class="line">  <span class="title function_">func2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;func1 結束執行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;func2 開始執行&quot;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;func2 結束執行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>()</span><br><span class="line"><span class="comment">// func1 開始執行</span></span><br><span class="line"><span class="comment">// func2 開始執行</span></span><br><span class="line"><span class="comment">// func2 結束執行</span></span><br><span class="line"><span class="comment">// func1 結束執行</span></span><br></pre></td></tr></table></figure>

<p>Call Stack 看起來會像 :<br><img src="/JavaScript-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-Execution-Context-%E8%88%87%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A-Call-Stack/call_stack.webp" alt="Call Stack"></p>
<p>執行流程 :</p>
<ol>
<li>首先處於全域執行環境(Global Execution Context)的程式會先進入 stack。</li>
<li>func1 被呼叫，放入 stack 的最上方，並執行函式。執行 func1 過程中呼叫 func2，停止執行 func1。</li>
<li>func2 被呼叫，將其放入 stack 的最上方，並執行函式。執行結束後將函式從 stack 中移除。</li>
<li>從 func1 停止位置繼續執行程式，完成後從 stack 中移除。</li>
<li>程式執行完畢，便將全域執行環境從 stack 中移除。</li>
</ol>
<blockquote>
<p>若 Call Stack 堆疊過高，超出記憶體所分配的空間，會導致 <strong>stack overflow</strong> 的問題。</p>
</blockquote>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.udemy.com/course/wilson-full-stack-web-development/">2023 網頁全端開發</a><br><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 提升(Hoisting)與暫時死區(TDZ)</title>
    <url>/JavaScript-%E6%8F%90%E5%8D%87-Hoisting-%E8%88%87%E6%9A%AB%E6%99%82%E6%AD%BB%E5%8D%80-TDZ/</url>
    <content><![CDATA[<p>JavaScript 在編譯階段，會掃描宣告的變數及函式，後儲存在 variable object 裡，使它們可以在宣告前被存取。</p>
<span id="more"></span>

<h1 id="提升-Hoisting"><a href="#提升-Hoisting" class="headerlink" title="提升(Hoisting)"></a>提升(Hoisting)</h1><p>JavaScript 在執行程式碼之前(編譯階段)，會先掃描程式中宣告的變數，並將它們儲存在變數環境物件(variable environment object)中，使某些類型的變數在宣告之前允許被存取。</p>
<table>
  <tr>
    <td></td>
    <td align="center">提升</td>
    <td align="center">原始值</td>
    <td align="center">作用域</td>
  </tr>
  <tr>
    <td align="center">函式宣告(function declaration)</td>
    <td align="center">⭕</td>
    <td align="center">實際函式</td>
    <td align="center">區塊作用域</td>
  </tr>
  <tr>
    <td align="center">var 宣告的變數</td>
    <td align="center">⭕</td>
    <td align="center">undefined</td>
    <td align="center">函式作用域</td>
  </tr>
  <tr>
    <td align="center">let / const 宣告的變數</td>
    <td align="center">⭕</td>
    <td align="center">&lt;uninitialized&gt;, TDZ</td>
    <td align="center">區塊作用域</td>
  </tr>
  <tr>
    <td align="center">函式表達式(function expression)、箭頭函式(arrow function)</td>
    <td align="center" colspan="3">跟據 var 宣告或 let / const 宣告而不同</td>
  </tr>
</table>

<h2 id="let-與-const-的提升"><a href="#let-與-const-的提升" class="headerlink" title="let 與 const 的提升"></a>let 與 const 的提升</h2><p>以 let 或 const 宣告的變數也會提升，但提升後的行為與 var 變數不同，初始值被設定為 unintialized，因此在宣告前存取變數會拋出 <code>ReferenceError: Cannot access &#39;a&#39; before initialization</code> 的錯誤。</p>
<p>程式範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h2 id="為什麼需要提升"><a href="#為什麼需要提升" class="headerlink" title="為什麼需要提升 ?"></a>為什麼需要提升 ?</h2><ol>
<li>在任何地方呼叫函式，不一定要先宣告後呼叫。</li>
<li>函式可以互相呼叫。</li>
</ol>
<h2 id="提升如何運作"><a href="#提升如何運作" class="headerlink" title="提升如何運作 ?"></a>提升如何運作 ?</h2><p>當呼叫一個函式時，即產生一個執行環境(Execution Context，以下簡稱 EC)，每個 EC 會有相對應的 variable object(以下簡稱 VO)，在 EC 中宣告的變數及函式都會儲存在 VO 中，若是函式，參數也會儲存到 VO 裡。</p>
<p>在進入 EC 時，JS 引擎會依照以下順序將變數儲存到 VO 中 :</p>
<p>對於函式的參數，會被儲存為 VO 中的屬性，若是沒有傳值，會被初始化為 undefined :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>那 VO 會像 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>對於函式宣告，同樣會儲存在 VO 裡面，值為函式的回傳值 :<br>假如 VO 中已有同名屬性，就會將其值覆蓋，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>所以 VO 會像 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後是變數宣告，同樣存在 VO 裡面，值設為 undefined :<br>若 VO 中已存在同名屬性，值不會改變。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>因此 VO 會像 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後總結一下，當程式執行進入 EC，會依照順序做三件事 :</p>
<ol>
<li>將參數存入 VO 並設定值，若無傳值則為 undefined。</li>
<li>將函式宣告存入 VO，若已有同名屬性則將其值覆蓋。</li>
<li>將變數宣告存入 VO，若已有同名屬性則將其忽略。</li>
</ol>
<h1 id="暫時死區-TDZ"><a href="#暫時死區-TDZ" class="headerlink" title="暫時死區(TDZ)"></a>暫時死區(TDZ)</h1><p>Temporal Dead Zone。指在變數「提升之後」及「賦值之前」的期間。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---- firstName 的暫時死區 ----</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName) <span class="comment">// ReferenceError: Cannot access &#x27;firstName&#x27; before initialization</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="string">&quot;ABen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color) <span class="comment">// ReferenceError: color is not defined</span></span><br></pre></td></tr></table></figure>

<p>從上面的程式碼中可以看出，因為 JS 引擎在程式執行前會先掃描程式碼中的變數，進而知道變數尚未初始化，所以若在變數宣告之前存取變數，引擎會將暫時死區中的變數值設為 uninitialized。當程式執行到宣告變數的地方，離開該變數的暫時死區，才可以被存取。</p>
<h2 id="為什麼需要暫時死區"><a href="#為什麼需要暫時死區" class="headerlink" title="為什麼需要暫時死區 ?"></a>為什麼需要暫時死區 ?</h2><ol>
<li>避免在宣告前使用變數。</li>
<li>為了實作 <strong>const</strong>。<ul>
<li>假如沒有暫時死區，若在以 const 宣告變數前存取該變數，那這個變數就會像以 var 宣告的變數一樣，初始值為 undefined，如此一來就違背 const 為常量的定義。</li>
</ul>
</li>
</ol>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">我知道你懂 hoisting，可是你了解到多深？</a><br><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - this ?</title>
    <url>/JavaScript-this/</url>
    <content><![CDATA[<p>在 JavaScript 中，<code>this</code> 指的是對目前執行環境的 ThisBinding。而在多數情況下，<code>this</code> 會因為函式的呼叫方式而有所不同。</p>
<span id="more"></span>

<h1 id="關於-this"><a href="#關於-this" class="headerlink" title="關於 this"></a>關於 this</h1><ul>
<li>呼叫函式即生成 <code>this</code>，指向當前函式執行環境。</li>
<li><code>this</code> 非靜態值，影響它的因素為函式的呼叫方法。</li>
<li>多數情況下，<code>this</code> 代表呼叫函式的物件。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">呼叫方法</th>
<th align="center">this</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Method</td>
<td align="center">呼叫函式的物件</td>
</tr>
<tr>
<td align="center">Simple function call</td>
<td align="center">undefined(嚴格模式) &#x2F; window(瀏覽器) &#x2F; global(Node.js)</td>
</tr>
<tr>
<td align="center">Arrow function</td>
<td align="center">父級函式的 <code>this</code> (lexical this)</td>
</tr>
<tr>
<td align="center">Event listener</td>
<td align="center">添加事件的 DOM 元素</td>
</tr>
<tr>
<td align="center"><code>call</code>、<code>apply</code>、<code>bind</code></td>
<td align="center">指定綁定的物件</td>
</tr>
</tbody></table>
<h2 id="以方法形式-Method-呼叫函式"><a href="#以方法形式-Method-呼叫函式" class="headerlink" title="以方法形式(Method)呼叫函式"></a>以方法形式(Method)呼叫函式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="number">2021</span>,</span><br><span class="line">  <span class="attr">calcAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2023</span> - <span class="variable language_">this</span>.<span class="property">year</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">aben.<span class="title function_">calcAge</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面以 aben 物件呼叫 calcAge 方法，<code>this</code> 即指向 aben 物件，所以 <code>this.year</code> 就等於 2021。</p>
<h2 id="直接呼叫函式-Simple-function-call"><a href="#直接呼叫函式-Simple-function-call" class="headerlink" title="直接呼叫函式(Simple function call)"></a>直接呼叫函式(Simple function call)</h2><p>在嚴格模式下， <code>this</code> 為 <code>undefined</code>。在非嚴格模式，瀏覽器中 <code>this</code> 為 <code>window</code>，Node.js 中 <code>this</code> 為 <code>global</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> boo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">boo</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>上面程式中雖然 boo 函式是在 obj 物件的 foo 方法中被呼叫，但因為 boo 函式中沒有特別指明 <code>this</code>，所以預設綁定為 <code>window</code>。</p>
<p>所以 <strong>this 代表的是呼叫函式的物件，而非函式本身</strong>。</p>
<p>而為了使 boo 函式的 <code>this</code> 綁定為 obj 物件，在較舊的程式碼中通常會宣告 <code>self</code> 變數儲存 foo 函式的 <code>this</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> boo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(self) <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">boo</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>而在 ES6 之後的方法為使用箭頭函式 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">boo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">boo</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h2 id="箭頭函式-Arrow-function"><a href="#箭頭函式-Arrow-function" class="headerlink" title="箭頭函式(Arrow function)"></a>箭頭函式(Arrow function)</h2><p>箭頭函式本身沒有 <code>this</code>，它的 <code>this</code> 必須從父級函式或父級作用域取得。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">boo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">boo</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>上面程式碼中因為 boo 函式為箭頭函式，所以 <code>this</code> 為從父級函式 foo 中所取得，指向 obj 物件。</p>
<p>陷阱範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>雖然上面程式中以 obj 呼叫 foo 函式，但因為 foo 函式為箭頭函式，所以從父級作用域取得的 <code>this</code> 為 <code>window</code>。</p>
<p>特別注意，建立物件使用的 <code>&#123;&#125;</code> 不具有區塊作用域 ! 所以 foo 函式的父級作用域為全域作用域。</p>
<p>因此<strong>永遠不要使用箭頭函式作為物件的方法</strong>。</p>
<h2 id="事件監聽-Event-listener"><a href="#事件監聽-Event-listener" class="headerlink" title="事件監聽(Event listener)"></a>事件監聽(Event listener)</h2><p>事件監聽中的 <code>this</code> 為綁定事件的 DOM 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>點我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>)</span><br><span class="line"></span><br><span class="line">btnEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// &lt;button id=&quot;btn&quot;&gt;點我&lt;/button&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>特別注意，若回調函式為箭頭函式，則 <code>this</code> 為從父級作用域也就是全域作用域取得之 <code>window</code>。</p>
<h2 id="bind-與-call-x2F-apply"><a href="#bind-與-call-x2F-apply" class="headerlink" title="bind 與 call &#x2F; apply"></a>bind 與 call &#x2F; apply</h2><p>使用 <code>bind</code>、<code>call</code>、<code>apply</code> 來強制綁定 <code>this</code>。</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>借用已建立的函式來創建新的函式，並將指定的物件綁訂為新函式的 <code>this</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFunc = getAge.<span class="title function_">bind</span>(aben)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newFunc</span>()) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>也可以在創建新函式的同時預先傳入參數 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFunc = add.<span class="title function_">bind</span>(<span class="variable language_">this</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newFunc</span>(<span class="number">1</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="call-x2F-apply"><a href="#call-x2F-apply" class="headerlink" title="call &#x2F; apply"></a>call &#x2F; apply</h3><p>使用給定的物件呼叫函式，並將 <code>this</code> 綁定為該物件。</p>
<p>使用 <code>call</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params">age, breed</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is a <span class="subst">$&#123;age&#125;</span>-year-old <span class="subst">$&#123;breed&#125;</span> breed dog.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callName.<span class="title function_">call</span>(aben, <span class="number">2</span>, <span class="string">&quot;mixed&quot;</span>) <span class="comment">// ABen is a 2-year-old mixed breed dog.</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>apply</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is a <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>-year-old <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span> breed dog.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callName.<span class="title function_">apply</span>(aben, [<span class="number">2</span>, <span class="string">&quot;mixed&quot;</span>]) <span class="comment">// ABen is a 2-year-old mixed breed dog.</span></span><br></pre></td></tr></table></figure>

<p>兩者差別在於傳遞參數的類型，<code>call</code> 為一般參數形式傳遞，<code>apply</code> 則是陣列形式傳遞。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://kuro.tw/posts/2017/10/12/What-is-THIS-in-JavaScript-%E4%B8%8A/">What’s THIS in JavaScript ? </a><br><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 原始類型(Primitive)與物件類型(Object)</title>
    <url>/JavaScript-%E5%8E%9F%E5%A7%8B%E9%A1%9E%E5%9E%8B-Primitive-%E8%88%87%E7%89%A9%E4%BB%B6%E9%A1%9E%E5%9E%8B-Object/</url>
    <content><![CDATA[<p>原始類型(Primitive)與物件類型(Object)的差別在於兩者儲存的位置以及儲存的值，原始類型存於 Call Stack 中且儲存實際值，物件類型存於 Heap 中且儲存對物件的參考地址。</p>
<span id="more"></span>

<h1 id="原始類型-Primitive"><a href="#原始類型-Primitive" class="headerlink" title="原始類型(Primitive)"></a>原始類型(Primitive)</h1><p>在 JavaScript 中的原始數據類型有 :</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>undefined</li>
<li>null</li>
<li>BigInt</li>
<li>Symbol</li>
</ul>
<h2 id="call-by-value"><a href="#call-by-value" class="headerlink" title="call by value"></a>call by value</h2><p>原始數據類型操縱的值為實際的賦值(call by value) :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> oldAge = age</span><br><span class="line">age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldAge) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面程式碼中因為宣告的變數是原始數據類型，所以儲存於 Call Stack 中，首先宣告 <code>age</code> 變數，JS 以變數名稱創建唯一的標識符(Identifier)，然後分配一塊記憶體並提供記憶體位址(Address)，最後將賦值(Value) <code>2</code> 存到記憶體中。</p>
<p>第二步宣告 <code>oldAge</code> 等於 <code>age</code>，JS 先創建標識符，後分配到另一記憶體位置，再將 <code>age</code> 的值存入記憶體。</p>
<p>最後，將 <code>age</code> 重新賦值為 <code>3</code>，JS 通過唯一的標識符，取得儲存 <code>age</code> 的記憶體位址，再將原來的 <code>2</code> 改成 <code>3</code>。</p>
<p>在 JS 引擎中 :<br><img src="/JavaScript-%E5%8E%9F%E5%A7%8B%E9%A1%9E%E5%9E%8B-Primitive-%E8%88%87%E7%89%A9%E4%BB%B6%E9%A1%9E%E5%9E%8B-Object/primitive_in_engine.webp" alt="原始類型儲存方式"></p>
<h1 id="物件類型-Object"><a href="#物件類型-Object" class="headerlink" title="物件類型(Object)"></a>物件類型(Object)</h1><p>在 JavaScript 中的物件類型有 :</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
</ul>
<h2 id="call-by-reference"><a href="#call-by-reference" class="headerlink" title="call by reference"></a>call by reference</h2><p>物件類型操縱的值為對物件的參考地址(call by reference) :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> black = aben</span><br><span class="line">black.<span class="property">age</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;black:&quot;</span>, black) <span class="comment">// &#123;age: 3&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;aben:&quot;</span>, aben) <span class="comment">// &#123;age: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面程式碼中，首先宣告 <code>aben</code> 物件，此物件會直接儲存在 Heap 裡面，JS 在 Call Stack 中創建唯一標識符 <code>aben</code>，分配記憶體空間，而裡面儲存的值為對 Heap 中物件記憶體位址的參考(reference)。</p>
<p>再來，宣告 <code>black</code> 物件等於 <code>aben</code> 物件，JS 同樣創建唯一標識符，分配記憶體空間，同樣儲存 Heap 中 <code>aben</code> 物件記憶體位址的參考，也就是說 <code>black</code> 與 <code>aben</code> 都指向同一物件。</p>
<p>最後 <code>black</code> 物件修改 <code>age</code> 值，因為 <code>black</code> 與 <code>aben</code> 實際上都指向同一物件，所以最終兩者都改為 <code>3</code>。</p>
<p>在 JS 引擎中 :<br><img src="/JavaScript-%E5%8E%9F%E5%A7%8B%E9%A1%9E%E5%9E%8B-Primitive-%E8%88%87%E7%89%A9%E4%BB%B6%E9%A1%9E%E5%9E%8B-Object/object_in_engine.webp" alt="物件類型的儲存方式"></p>
<h2 id="call-by-sharing"><a href="#call-by-sharing" class="headerlink" title="call by sharing"></a>call by sharing</h2><p>讓作為參數傳入的物件與函式中的參數物件共享同一物件。</p>
<p>看看下面的範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">changeAge</span>(aben)) <span class="comment">// &#123;age: 3&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aben) <span class="comment">// &#123;age: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>aben</code> 物件竟然還是原來的值，若物件類型是 call by reference 的話，<code>aben</code> 應該要大一歲才對。</p>
<p>這是因為當 <code>aben</code> 物件作為參數傳入函式時，是讓函數中的 <code>obj</code> 參數與 <code>aben</code> 共享一個物件，若是使用 <code>obj.age</code> 的方式重新賦值，那 <code>aben</code> 的年齡確實會改變，但是實際上在函式中卻是將一個新的物件賦值給 <code>obj</code> 參數，這樣 <code>obj</code> 與 <code>aben</code> 就指向不同的物件，也就是說函式執行後另外創建了一個物件，因此 <code>aben</code> 的年齡並沒有改變。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></li>
<li><a href="https://hulitw.medium.com/variable-and-frontdesk-a53a0440af3c">從博物館寄物櫃理解變數儲存模型</a></li>
<li><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html">[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li><a href="https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-call-by-value-%E9%82%84%E6%98%AFreference-%E5%8F%88%E6%88%96%E6%98%AF-sharing-22a87ca478fc">JS 基本觀念：call by value 還是 reference 又或是 sharing?</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 解構賦值(Destructuring Assignment)</title>
    <url>/JavaScript-%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC-Destructuring-Assignment/</url>
    <content><![CDATA[<p>解構賦值可以用來提取陣列或物件中的資料，讓原本可能需要迴圈或迭代的功能可以用更簡易的語句來達成。而展開運算符與其餘運算符可以讓我們更靈活的使用函式，在處理從 API 取得的資料時也更加容易。</p>
<span id="more"></span>

<h1 id="解構陣列-Destructuring-Array"><a href="#解構陣列-Destructuring-Array" class="headerlink" title="解構陣列(Destructuring Array)"></a>解構陣列(Destructuring Array)</h1><p>範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// a = 1, b = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 略過某些值</span></span><br><span class="line"><span class="keyword">const</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a = 1, b = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交換變數值</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">;[a, b] = [b, a] <span class="comment">// a = 2, b = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套的陣列</span></span><br><span class="line"><span class="keyword">const</span> [a, [b, c]] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]] <span class="comment">// a = 1, b = 2, c = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 設定默認值</span></span><br><span class="line"><span class="keyword">const</span> [a = <span class="number">0</span>, b = <span class="number">1</span>, c] = [<span class="number">1</span>] <span class="comment">// a = 1, b = 1, c = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字串</span></span><br><span class="line"><span class="keyword">const</span> [a] = <span class="string">&quot;ABen&quot;</span> <span class="comment">// a = A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其餘運算符(Rest Operator)</span></span><br><span class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a = 1, b = [2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="解構物件-Destructuring-Object"><a href="#解構物件-Destructuring-Object" class="headerlink" title="解構物件(Destructuring Object)"></a>解構物件(Destructuring Object)</h1><p>範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> &#123; dog &#125; = &#123; <span class="attr">dog</span>: <span class="string">&quot;ABen&quot;</span> &#125; <span class="comment">// dog = ABen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 賦予新的變數名</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">dog</span>: dogName &#125; = &#123; <span class="attr">dog</span>: <span class="string">&quot;ABen&quot;</span> &#125; <span class="comment">// dogName = ABen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 設定默認值</span></span><br><span class="line"><span class="keyword">const</span> &#123; dog, age = <span class="number">2</span>, color &#125; = &#123; <span class="attr">dog</span>: <span class="string">&quot;ABen&quot;</span> &#125; <span class="comment">// dog = ABen, age = 2, color = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變變數</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">111</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">222</span>((&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)) <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  在 JS 中 `&#123;&#125;` 代表程式區塊，所以無法被賦值，需要在外部包 `()` 代表運算，才可正常執行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套的物件</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; b, c &#125;,</span><br><span class="line">&#125; = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125; &#125; <span class="comment">// b = 2, c = 3</span></span><br></pre></td></tr></table></figure>

<h1 id="展開運算符-Spread-Operator-與其餘運算符-Rest-Operator"><a href="#展開運算符-Spread-Operator-與其餘運算符-Rest-Operator" class="headerlink" title="展開運算符(Spread Operator)與其餘運算符(Rest Operator)"></a>展開運算符(Spread Operator)與其餘運算符(Rest Operator)</h1><p>為 ES6 的新特性，兩者語法皆為 <code>...</code>。</p>
<h2 id="展開運算符-Spread-Operator"><a href="#展開運算符-Spread-Operator" class="headerlink" title="展開運算符(Spread Operator)"></a>展開運算符(Spread Operator)</h2><p>可以將陣列展開成個別的值。在定義陣列或函式呼叫傳入陣列時使用。</p>
<p>組合陣列 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [<span class="number">0</span>, ...arr]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>複製陣列 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> copyArr = [...arr]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copyArr) <span class="comment">// [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是展開運算符為淺複製(shallow-copy)，對於子物件只會複製其參考值(reference)。</p>
<p>呼叫函式時傳入陣列 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c) <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(...arr)</span><br></pre></td></tr></table></figure>

<p>只有可迭代的值可以使用展開運算符傳入函式。可迭代的值包含 String、Array、Map、Set，但不包括 Object。</p>
<p>組合物件 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> newObj = &#123; ...obj, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj) <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="其餘運算符-Rest-Operator"><a href="#其餘運算符-Rest-Operator" class="headerlink" title="其餘運算符(Rest Operator)"></a>其餘運算符(Rest Operator)</h2><p>將剩餘的值包裝成一個陣列。</p>
<p>解構陣列 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">// a = 1, b = 2, c = [3, 4]</span></span><br></pre></td></tr></table></figure>

<p>特別注意，使用其餘運算符的元素必須要是最後一個元素，並且在每次解構賦值中只能使用一次。</p>
<p>解構物件 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, ...obj &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125; <span class="comment">// a = 1, obj = &#123;b: &#123;c: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>函式其餘參數 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若參數原本為陣列</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title function_">sum</span>(...arr) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>當其餘參數沒有傳入實際值時，會變空陣列，而不是 <code>undefined</code>。</p>
<p>其餘參數的設計是為了取代函式中的 <code>arguments</code> 關鍵字，<code>arguments</code> 實際為包含所有傳入參數的類陣列(array-like)物件，所以本身不具備陣列相關的方法，因此不建議使用 <code>arguments</code>。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/destructuring.html">解構賦值· 從 ES6 開始的 JavaScript 學習生活</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/rest_spread.html">展開運算符與其餘運算符· 從 ES6 開始的 JavaScript 學習生活</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 可選鏈(Optional Chaining)</title>
    <url>/JavaScript-%E5%8F%AF%E9%81%B8%E9%8F%88-Optional-Chaining/</url>
    <content><![CDATA[<p>在取得 API 響應並存取數據時，時常會遇到 <code>TypeError: Cannot read property &#39;xxx&#39; of null</code> 或是 <code>TypeError: Cannot read property &#39;xxx&#39; of undefined</code> 的錯誤，而造成錯誤的原因就是試圖從 nullish value 上讀取屬性或調用方法，為了解決這個問題，可以在取值時使用可選鏈，以免程式拋出錯誤。</p>
<span id="more"></span>

<h1 id="可選鏈-Optional-Chaining"><a href="#可選鏈-Optional-Chaining" class="headerlink" title="可選鏈(Optional Chaining)"></a>可選鏈(Optional Chaining)</h1><p>用來避免在從 nullish value(<code>null</code> 或 <code>undefined</code>)上讀取屬性或調用方法時拋出錯誤，語法為 <code>?.</code>。</p>
<p>使用範例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = &#123;</span><br><span class="line">  <span class="attr">dog</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用可選鏈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets.<span class="property">cat</span>.<span class="property">name</span>) <span class="comment">// TypeError: Cannot read properties of undefined (reading &#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可選鏈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets.<span class="property">cat</span>?.<span class="property">name</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>當存取物件中不存在的屬性時，若沒有使用可選鏈就會報錯，而使用可選鏈則會回傳 <code>undefined</code>。</p>
<p>在可選鏈出現之前，為了避免錯誤，通常會這麼做 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = &#123;</span><br><span class="line">  <span class="attr">dog</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pets.<span class="property">cat</span> &amp;&amp; pets.<span class="property">cat</span>.<span class="property">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pets.<span class="property">cat</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣的寫法雖然可以避免錯誤，但是若需要存取巢狀物件的深層屬性時，那就必須要更多的判斷才能確保程式不報錯，所以為了簡潔與可讀性，使用可選鏈 <code>?.</code> 是更好的選擇。</p>
<p>調用方法 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aben = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aben.<span class="property">fly</span>?.() ?? <span class="string">&quot;Method does not exist&quot;</span>) <span class="comment">// Method does not exist</span></span><br></pre></td></tr></table></figure>

<p>上面程式碼中呼叫 <code>aben</code> 物件中不存在的 <code>fly</code> 方法，但因為使用可選鏈，所以回傳 <code>undefined</code> 而不會報錯，並且搭配空值合併運算符(Nullish Coalescing Operator) <code>??</code>，以回傳除了 <code>undefined</code> 與 <code>null</code> 的其他值。</p>
<p>存取陣列數據 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;ABen&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets[<span class="number">0</span>]?.<span class="property">name</span> ?? <span class="string">&quot;Pet array empty&quot;</span>) <span class="comment">// ABen</span></span><br></pre></td></tr></table></figure>

<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.udemy.com/course/the-complete-javascript-course/">The Complete JavaScript Course 2023: From Zero to Expert!</a></li>
<li><a href="https://www.tpisoftware.com/tpu/articleDetails/2533">JavaScript 可選鏈運算符 (?.) 與 空值合併運算符 (??) 介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
